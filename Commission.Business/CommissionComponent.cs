//====================================================================================================
// Code generated with Motion: BC Gen (Build 2.2.4750.27570)
// Layered Architecture Solution Guidance (http://layerguidance.codeplex.com)
//
// Generated by fmuraya at SOFTBOOKSSERVER on 08/03/2013 18:31:33 
//====================================================================================================


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Windows;
using fCommissions.Commission.Entities;
using fanikiwaGL.Entities;
using fanikiwaGL.Business;
using fanikiwaGL.Framework;


namespace fCommissions.Commission.Business
{
    /// <summary>
    /// Commission business component.
    /// </summary>
    public partial class CommissionComponent
    {
        #region Compute Commission By Rule
        /// <summary>
        /// Compute commission given a Commission transaction and a commission collection rule
        /// </summary>
        /// <returns>Returns a List<Offer> object.</returns>
        public decimal ComputeByCommissionRule(decimal Amount, CommissionRule rule)
        {
            if (rule == null) return 0.00M;

            decimal commision = 0.00M;
            decimal _amount = 0.00M;

            if (Amount >= 0)
            {
                _amount = Amount;
            }
            if (Amount < 0)
            {
                _amount = Amount * -1;
            }
            if (rule ==null) //No rule set
            {
                return 0;
            }

            if (rule is FlatRateRule) //return a flat figure
            {
               return  ComputeFlat((FlatRateRule) rule, _amount);
            }
            else if (rule is TieredRule)  //commpute commission in various layers/tiers
            {
                return ComputeTiered((TieredRule)rule, _amount);
            }
            else if (rule is LookupRule)  //lookup a commission from a table
            {
                return ComputeLookup((LookupRule)rule, _amount);
            }

            return commision;
        }

        private decimal ComputeLookup(LookupRule rule, decimal Amount)
        {
            LookupRow[] terms = rule.LookupTable.ToArray();
            decimal commission = 0;
            for (int i = 0; i < terms.Length; i++)
            {
                bool _absolute = terms[i].Absolute;
                decimal _max = terms[i].Max;
                decimal _min = terms[i].Min;
                decimal _rate = terms[i].Rate;

                if (Amount >= _min && Amount <= _max)
                {
                    if (_absolute)
                    {
                        commission = _rate;
                    } //return a flat rate
                    else
                    {
                        _rate = _rate / 100;
                        commission = Amount * _rate;
                    }
                }
            }
            return commission;
        }
        private decimal ComputeFlat(FlatRateRule flat, decimal Amount)
        {
            decimal commission = 0;
            if (flat.Absolute)
            {
                commission = flat.Rate;
            } //return a flat rate
            else
            {
                commission = Amount * flat.Rate;
            } //return a flat figure based on percent %
            return commission;
        }
        private decimal ComputeTiered(TieredRule rule, decimal Amount)
        { 
            return ComputeTiered( rule,  Amount, 0);
        }
        private decimal ComputeTiered(TieredRule rule, decimal Amount, decimal min )
        {
            /*
             * 
             */

            //If Amount is less than minimim, dont charge
            if (Amount < min) { return 0; }

            decimal commission = 0.0M; decimal amtInBracket;
            int bracketId = 0;
            bool cont = true;
            //loop through the lookup computing the neccessary taxes within the bracket
            //while returning the charged amount
            foreach (var bracket in rule.LookupTable)
            {
                ++bracketId;
                bool isLastBracket = (rule.LookupTable.Count == bracketId);
                if (cont)
                    commission += AmountInBracket(bracket.Absolute,Amount, bracket.Min, bracket.Max, bracket.Rate, isLastBracket, out  amtInBracket, out cont);
                else
                    break;

                //keep reducing amt to tax by amt already taxed
                Amount -= amtInBracket;
            }

            return commission;

        }
        private decimal AmountInBracket(bool absolute,decimal TxnAmount, decimal From, decimal To, decimal Rate, bool isLastBracket, out decimal amtInTier, out bool cont)
        {
            if (isLastBracket)  //last bracket
            {
                amtInTier = TxnAmount;
                decimal commission = absolute ? Rate : amtInTier * Rate / 100;
                cont = false;
                return commission;

            }
            else if (TxnAmount > To)  //greator than the bracket
            {
                amtInTier = (To - From);
                decimal commission = absolute ? Rate : amtInTier * Rate / 100;
                cont = true;
                return commission;
            }
            else
            {
                amtInTier = TxnAmount;
                decimal commission = absolute ? Rate : amtInTier * Rate / 100;
                cont = false;
                return commission;
            }

        }

        #endregion

        #region Computation calling types

        public decimal ComputeCommissionByTransactionType(decimal subject, TransactionType tt)
        {
            CommissionRule rule = GetCommissionRuleFromTransactionType(tt);
            return ComputeByCommissionRule(subject, rule);
        }
        public decimal ComputeCommissionByTransactionTypeId(decimal Amount, int ttId)
        {
            StaticTransactionsComponent sPost = new StaticTransactionsComponent();
            return ComputeCommissionByTransactionType(Amount, sPost.GetTransactionType(ttId));
        }
        #endregion

        #region Make Commission Rules
        public CommissionRule GetCommissionRuleFromTransactionType(TransactionType tt)
        {
            CommissionRule rule = null;

            rule = GetCommissionRule(tt.TransactionTypeID);
            return rule;
        }
        public CommissionRule GetCommissionRule(int tt)
        {
            //get transactiontype from TT
            //Use this for all general ledger methods that does not post
            StaticTransactionsComponent sPost = new StaticTransactionsComponent();
            TransactionType TT = sPost.GetTransactionType(tt);
            if (string.IsNullOrEmpty(TT.CommComputationMethod)) return null;

            switch (TT.CommComputationMethod)
            {
                case "L": //tiered
                    LookupRule lrule = new LookupRule();
                    if (TT.TieredTableId == 0)
                        throw new ArgumentNullException("TieredTableId", "TieredTableId field not set in TransctionType ["+tt+"]");
                    List<LookupRow> llr = this.GetLookTable(TT.TieredTableId);
                    lrule.LookupTable = llr;
                    return lrule;
                case "T": //tiered
                    TieredRule rule = new TieredRule();
                    if (TT.TieredTableId == 0)
                        throw new ArgumentNullException("TieredTableId", "TieredTableId field not set in TransctionType [" + tt + "]");
                    List<LookupRow> lr = this.GetLookTable(TT.TieredTableId);
                    rule.LookupTable = lr;
                    return rule;
                case "F": //flat rule
                    FlatRateRule flat = new FlatRateRule();
                    flat.Absolute = TT.Absolute;
                    flat.Rate = TT.CommissionAmount;
                    //fill it up
                    return flat;
            }

            return null;
        }

        private List<LookupRow> GetLookTable(int Id)
        {
            //get transactiontype from TT
            //Use this for all general ledger methods that does not post
            StaticTransactionsComponent sPost = new StaticTransactionsComponent();
            TransactionType TT = sPost.GetTransactionType(Id);
            if (TT == null) throw new ArgumentNullException("TransactionType", "TransactionType["+Id+"] does not exist");
            List < LookupRow > lr = new List<LookupRow>();
            List<TieredDet> trd = sPost.GetTieredTable(TT.TieredTableId);
            foreach (var t in trd)
            {
                LookupRow lookupTable = new LookupRow();
                lookupTable.Id = t.Id;
                lookupTable.Min = t.Min;
                lookupTable.Max = t.Max;
                lookupTable.Rate = t.Rate;

                lr.Add(lookupTable);
            }
            return lr;
        }
        #endregion


        #region STO Commissions  Computations

        public decimal ComputeCommissionByTransactionType(STO _sto, TransactionType tt)
        {
            CommissionComponent cc = new CommissionComponent();
            CommissionRule rule = cc.GetCommissionRuleFromTransactionType(tt);
            return this.ComputeByCommissionRule(_sto, rule);
        }
        public decimal ComputeByCommissionRule(STO _sto, CommissionRule rule)
        {
            if (rule == null) return 0.00M;


            decimal commision = 0.00M;
            decimal _amount = 0.00M;

            if (_sto.TotalToPay >= 0)
            {
                _amount = _sto.TotalToPay;
            }
            if (_sto.TotalToPay < 0)
            {
                _amount = _sto.TotalToPay * -1;
            }

            if (rule is FlatRateRule) //return a flat figure
            {
                FlatRateRule flat = (FlatRateRule)rule; //cast the rule into flat rate rule

                if (flat.Absolute)
                {
                    commision = flat.Rate;
                } //return a flat rate
                else
                {
                    commision = _amount * flat.Rate;
                } //return a flat figure based on percent %
            }
            else if (rule is TieredRule)  //lookup a commission from a table
            {
                TieredRule tiered = (TieredRule)rule; //cast the rule into Tiered rule

                LookupRow[] terms = tiered.LookupTable.ToArray();

                for (int i = 0; i < terms.Length; i++)
                {
                    bool _absolute = terms[i].Absolute;
                    decimal _max = terms[i].Max;
                    decimal _min = terms[i].Min;
                    decimal _rate = terms[i].Rate;

                    if (_amount >= _min && _amount <= _max)
                    {
                        if (_absolute)
                        {
                            commision = _rate;
                        } //return a flat rate
                        else
                        {
                            _rate = _rate / 100;
                            commision = _amount * _rate;
                        }
                    }
                }
            }

            return commision;
        }
        public decimal GetCommissionAmountForSTO(STO _sto)
        {
            //variable to hold commission
            decimal _commission = 0;
            //compute commission if _sto.ChargeCommFlag==true && !_sto.CommissionPaidFlag
            if (_sto.ChargeCommFlag && !_sto.CommissionPaidFlag)
            {
                switch (_sto.CommSourceFlag)
                {
                    case (short)STOCommSourceFlag.NoCommission:
                        return _commission;
                    case (short)STOCommSourceFlag.STO:
                        return _sto.CommissionAmount;
                    case (short)STOCommSourceFlag.TransactionType:
                        StaticTransactionsComponent sPost = new StaticTransactionsComponent();
                        //get transaction type from sto debit transaction type
                        TransactionType DrTxnType = sPost.GetTransactionType(_sto.DrTxnType);
                        //get the commission, pass sto and transaction type
                        _commission = this.ComputeCommissionByTransactionType(_sto, DrTxnType);
                        break;
                }
            }
            return _commission;
        }
        #endregion



    }
}